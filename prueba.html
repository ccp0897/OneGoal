<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Burbuja Reactiva al Cursor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/perlin-noise/1.0.0/perlin-noise.min.js"></script> <!-- Perlin Noise -->
    <style>
        body {
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background: transparent;
        }
        canvas {
            display: block;
            cursor: pointer;
        }
    </style>
</head>
<body>

<script>
    // Crear la escena
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

    document.body.appendChild(renderer.domElement);

    // Crear la esfera (burbuja)
    const geometry = new THREE.SphereGeometry(1, 64, 64);
    const material = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0.0 },
            color1: { value: new THREE.Color("#A7F407") }, // Verde
            color2: { value: new THREE.Color("#779636") }, // Azul
            color3: { value: new THREE.Color("#3A412D") }, // Morado
            color4: { value: new THREE.Color("black") },   // Negro
            fresnelColor: { value: new THREE.Color("#CCCCCC") },
        },
        transparent: true,
        vertexShader: `
            varying vec3 vNormal;
            varying vec2 vUv;
            varying vec3 vPosition;
            uniform float time;

            void main() {
                vNormal = normalize(normal);
                vUv = uv;
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            varying vec3 vNormal;
            varying vec2 vUv;
            varying vec3 vPosition;
            uniform float time;
            uniform vec3 color1;
            uniform vec3 color2;
            uniform vec3 color3;
            uniform vec3 color4;
            uniform vec3 fresnelColor;

            float smoothWave(float value, float speed) {
                return 0.5 + 0.4 * sin(value * speed + time);
            }

            void main() {
                float wave1 = smoothWave(vUv.y, 10.0);
                float wave2 = smoothWave(vUv.x, 15.0);
                float wave3 = smoothWave(vUv.y + vUv.x, 8.0);

                vec3 colorMix = mix(color1, color2, wave1);
                colorMix = mix(colorMix, color3, wave2);
                colorMix = mix(colorMix, color4, wave3 * 0.2);

                float fresnel = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                vec3 fresnelEffect = fresnel * fresnelColor * 0.5; 

                vec3 finalColor = min(colorMix + fresnelEffect, vec3(0.9, 0.9, 0.9));
                float alpha = 0.9;

                gl_FragColor = vec4(finalColor, alpha);
            }
        `,
    });

    const sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);

    // Posición de la cámara
    camera.position.z = 2.5;

    // Ajustar el tamaño del canvas al de la burbuja
    function resizeCanvas() {
        const size = window.innerHeight < window.innerWidth ? window.innerHeight * 0.5 : window.innerWidth * 0.5;
        renderer.setSize(size, size);
        camera.aspect = 1;
        camera.updateProjectionMatrix();
    }

    // Movimiento orgánico
    let timeOffset = Math.random() * 100;
    // Implementación propia de Simplex Noise
class SimplexNoise {
    constructor() {
        this.grad3 = [
            [1,1,0], [-1,1,0], [1,-1,0], [-1,-1,0], 
            [1,0,1], [-1,0,1], [1,0,-1], [-1,0,-1], 
            [0,1,1], [0,-1,1], [0,1,-1], [0,-1,-1]
        ];
        this.p = [];
        for (let i = 0; i < 256; i++) {
            this.p.push(Math.floor(Math.random() * 256));
        }
        this.perm = [];
        for (let i = 0; i < 512; i++) {
            this.perm[i] = this.p[i & 255];
        }
    }

    dot(g, x, y) {
        return g[0] * x + g[1] * y;
    }

    noise(xin, yin) {
        let F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
        let s = (xin + yin) * F2;
        let i = Math.floor(xin + s);
        let j = Math.floor(yin + s);
        let G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
        let t = (i + j) * G2;
        let X0 = i - t;
        let Y0 = j - t;
        let x0 = xin - X0;
        let y0 = yin - Y0;
        let i1, j1;
        if (x0 > y0) {
            i1 = 1; j1 = 0;
        } else {
            i1 = 0; j1 = 1;
        }
        let x1 = x0 - i1 + G2;
        let y1 = y0 - j1 + G2;
        let x2 = x0 - 1.0 + 2.0 * G2;
        let y2 = y0 - 1.0 + 2.0 * G2;
        let ii = i & 255;
        let jj = j & 255;
        let gi0 = this.perm[ii + this.perm[jj]] % 12;
        let gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
        let gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
        let n0 = 0, n1 = 0, n2 = 0;
        let t0 = 0.5 - x0 * x0 - y0 * y0;
        if (t0 < 0) n0 = 0.0;
        else {
            t0 *= t0;
            n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
        }
        let t1 = 0.5 - x1 * x1 - y1 * y1;
        if (t1 < 0) n1 = 0.0;
        else {
            t1 *= t1;
            n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
        }
        let t2 = 0.5 - x2 * x2 - y2 * y2;
        if (t2 < 0) n2 = 0.0;
        else {
            t2 *= t2;
            n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
        }
        return 70.0 * (n0 + n1 + n2);
    }
}

// Instanciar Simplex Noise
const simplex = new SimplexNoise();

// Nueva función para obtener valores de ruido
function getNoiseValue(t, offset) {
    return simplex.noise(t * 0.5 + offset, 0) * 0.3;
}

// 🔹 Aquí sigue el resto de tu código 🔹

// Variables para la interacción con el cursor
let mouseX = 0, mouseY = 0;
let targetX = 0, targetY = 0;


function animate() {
    requestAnimationFrame(animate);
    material.uniforms.time.value += 0.02;

    let t = performance.now() * 0.0001;
    
    // Movimiento suave con Simplex Noise
    sphere.position.x = getNoiseValue(t, 10) * 0.3 + mouseX * 0.15;
    sphere.position.y = getNoiseValue(t, 20) * 0.3 - mouseY * 0.15;

    // Interpolación suave para evitar cambios bruscos
    mouseX += (targetX - mouseX) * 0.05;
    mouseY += (targetY - mouseY) * 0.05;

    // Inclinación ligera hacia el cursor
    sphere.rotation.y = mouseX * 0.3;
    sphere.rotation.x = -mouseY * 0.3;

    renderer.render(scene, camera);
}


    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
    animate();
</script>

</body>
</html>
